/**
 * 两棵树的diff算法时间复杂度 O(n^3),Vue做了优化，转化为了 O(n)，
 * 前端中很少进行跨层级的移动 Dom 元素。所以 v-dom 只会对同一个层级的元素进行比较
 * 
 * 理解：
 * 1、先同级比较，在比较子节点
 * 2、先一方有儿子，一方没儿子的情况
 * 3、都有儿子的情况
 * 4、递归比较子节点
 * 
 * 源码位置：
 * src/core/vdom/patch.js --- function patch
 * 
 * 
 * updateChildren函数，双指针比对的（diff）优化策略：
 * 1、先比较两头
 * 2、再比较两尾
 * 3、用 新的头 比 旧的尾
 * 4、用 新的尾 比 旧的头
 * 5、上面都不满足：
 * 通过key优化：用新的当前结点的key，到老的里面找，找到后，
 * 就把老的节点移到对应位置，之后依次后移，
 * 旧的节点多出来的，删除。 新的不足的添加
 * 
 * 
 * v-for中为什么要有key？
 * key主要是用于做dom的diff的。
 * 
 * 典型的例子：
 * <li v-for="item in arr">  --- arr 中有三个对象，有属性check和id
 *    <input type="checkbox" :value="item.check">
 *    {{item.check}}
 * </li>
 * 外面整一个 button，触发 remove方法
 * remove方法可以 删除arr的头一个元素，arr.shift();
 * 你运行后，勾选上第一个checkbox，然后按下按钮，删除
 * 会发现第一个元素删除了，但是： 当前的第一个（原先第二个）被勾选上了
 * 
 * 为什么会这样？
 * 首先，本质上：删除的其实是最后一个元素，而不是第一个元素，为什么？
 * （勾选最后一个元素，再点按钮删除，会发现其他元素不会有勾选状态）
 * ---- vue的复用策略：一样的元素会优先选择复用
 * 他直接是暴力比对的，因为你！！没有设置key！！所以他会看是不是同一个标签
 * 一样就复用，标签内容的值不同就修改（相当于操作了一次dom），不会管你是不是checkbox选中状态
 * 复用完后，多出来的标签，删掉
 * 
 * 
 * 注意，使用索引没法解决问题。（除非静态列表/数组）
 * 删除一个元素，改变了其他数组元素对应的索引（所以对象属性有id）
 * 
 * 如果有key（不加key。vue默认用索引，就地复用的策略 ）
 * （大部分就只需要移动，不需要重新的创建/操作dom）
 */

